# 类的定义

    我把对象比作塑料盒子。类（class）则像是制作盒子用的模具。
    如果想要在Python 中创建属于自己的对象，首先你必须用关键词class 来定义一个类。


    假设你想要定义一些对象用于记录联系人，每个对象对应一个人。首先需要定义Person 类作为生产对象的模具。
    在接下来的几个例子中，我们会不停更新这个类的内容，从最简单的开始，直到它成为一个可以实际使用的类。

**步骤1：**

    首先创建的是最简单的类，即一个没有任何内容的空类：
```py
class Person():
    pass
```
    同函数一样，用pass 表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再省略。
    你可以通过类名来创建对象，同调用函数一样：
    someone = Person()
    在这个例子中，Person() 创建了一个Person 类的对象，并给它赋值someone 这个名字。但是，由于我们的Person 类是空的，所以由它创建的对象someone 实际上什么也做不了。
    实际编程中，你永远也不会创建这样一个没用的类，我在这里只是为了从零开始引出后面每一步的内容。

**步骤2：**

    我们来试着重新定义一下Person 类。这一次，将Python 中特殊的对象初始化方法__init__ 放入其中：
    
```py
class Person():
	def __init__(self):
		pass
```
我承认__init__() 和self 看起来很奇怪，但这就是实际的Python 类的定义形式。
__init__() 是Python 中一个特殊的函数名，用于根据类的定义创建实例对象。
self 参数指向了这个正在被创建的对象本身。
当你在类声明里定义__init__() 方法时，第一个参数必须为self。
尽管self 并不是一个Python 保留字，但它很常用。没有人（包括你自己）在阅读你的代码时需要猜测使用self的意图。`

**步骤3：**

    尽管我们添加了初始化方法，但用这个Person 类创建的对象仍然什么也做不了。
    即将进行的第三次尝试要更吸引人了，你将学习如何创建一个简单可用的Python 对象。
    这一次，会在初始化方法中添加name 参数：
```py

class Person():
	def __init__(self, name):
		self.name = name
```
现在，用Person 类创建一个对象，为name 特性传递一个字符串参数：
hunter = Person('Elmer Fudd')
上面这短短的一行代码实际做了以下工作：
查看Person 类的定义；
在内存中实例化（创建）一个新的对象；
调用对象的__init__ 方法，将这个新创建的对象作为self 传入，并将另一个参数（'Elmer-Fudd'）作为name 传入；
将name 的值存入对象；
返回这个新的对象；
将名字hunter 与这个对象关联。
这个新对象与任何其他的Python 对象一样。你可以把它当作列表、元组、字典或集合中的元素，也可以把它当作参数传递给函数，或者把它做为函数的返回结果。

我们刚刚传入的name 参数此时又在哪儿呢？它作为对象的特性存储在了对象里。可以直接
对它进行读写操作：
```py
print('The mighty hunter: ', hunter.name)
```

*补充：*

    记住，在Person 类定义的内部，你可以直接通过self.name 访问name 特性。而当创建了一个实际的对象后，例如这里的hunter，需要通过hunter.name 来访问它。
    在类的定义中，__init__ 并不是必需的。只有当需要区分由该类创建的不同对象时，才需要指定__init__ 方法。